import{_ as e,c as t,o as a,a5 as r}from"./chunks/framework.BAO6c_AF.js";const g=JSON.parse('{"title":"归并排序","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/021-MergeSort.md","filePath":"algorithm/021-MergeSort.md","lastUpdated":1729870203000}'),o={name:"algorithm/021-MergeSort.md"},p=r('<h1 id="归并排序" tabindex="-1">归并排序 <a class="header-anchor" href="#归并排序" aria-label="Permalink to &quot;归并排序&quot;">​</a></h1><p>1）左部分排好序、右部分排好序、利用merge过程让左右整体有序</p><p>2）merge过程：谁小拷贝谁，直到左右两部分所有的数字耗尽，拷贝回原数组</p><p>3）递归实现和非递归实现</p><p>4）时间复杂度O(n * logn)</p><p>5）需要辅助数组，所以额外空间复杂度O(n)</p><p>6）归并排序为什么比O(n^2)的排序快？因为比较行为没有浪费！</p><p>7）利用归并排序的便利性可以解决很多问题 - 归并分治 - 下节课</p><p>注意：</p><p>有些资料说可以用原地归并排序，把额外空间复杂度变成O(1)，不要浪费时间去学</p><p>因为原地归并排序确实可以省空间，但是会让复杂度变成O(n^2)</p><p>有关排序更多的概念、注意点、闭坑指南，将在后续课程继续</p>',12),_=[p];function n(s,c,i,d,l,m){return a(),t("div",null,_)}const f=e(o,[["render",n]]);export{g as __pageData,f as default};
