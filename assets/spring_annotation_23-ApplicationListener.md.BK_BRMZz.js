import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.BBnPlPAH.js";const t="/assets/image-20220210190535225.xIoQk4xk.png",p="/assets/image-20220210190748526.0ws93sI9.png",e="/assets/image-20220211131657698.Cq1pMqDw.png",l="/assets/image-20220211131844702.BeHc2LqZ.png",h="/assets/image-20220211144541344.CQbBKtA-.png",k="/assets/image-20220211144715398.BgxXMmf0.png",r="/assets/image-20220211144929631.DQ6X5gYh.png",o="/assets/image-20220211145322719.C0g9pdKj.png",c="/assets/image-20220211145709631.C7peDcqw.png",g="/assets/image-20220211145934643.D9bninoX.png",E="/assets/image-20220211150614524.hCdu91QJ.png",d="/assets/image-20220211150939196.DEZXRd4_.png",b=JSON.parse('{"title":"Spring注解驱动开发【源码】——ApplicationListener用法&原理","description":"","frontmatter":{"title":"Spring注解驱动开发【源码】——ApplicationListener用法&原理","date":"2022-02-08T22:00:21.000Z","tags":null},"headers":[],"relativePath":"spring/annotation/23-ApplicationListener.md","filePath":"spring/annotation/23-ApplicationListener.md","lastUpdated":1729870203000}'),y={name:"spring/annotation/23-ApplicationListener.md"},A=n('<p>下面来谈一下ApplicationListener：监听容器中发布的事件，事件驱动模型开发。</p><p>点进去可以看到，它是一个接口，并且接口有泛型。也就是说，它会监听ApplicationEvent及其子类下面的事件。</p><p><img src="'+t+`" alt="image-20220210190535225"></p><p>我们写一个简单的事件：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.atqingke.ext;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.context.ApplicationEvent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.context.ApplicationListener;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.stereotype.Component;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @Author pengbin007</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @Date 2022/2/10 18:57</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyApplicationListener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ApplicationEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 当容器中发布此事件后，方法触发</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onApplicationEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ApplicationEvent </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;收到事件：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>那么如何发布这个事件呢？在applicationContext里面就有发布事件的方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.atqingke.test;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.atqingke.ext.ExtConfig;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.junit.Test;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.context.ApplicationEvent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @Author pengbin007</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @Date 2022/2/10 15:52</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ExtTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        AnnotationConfigApplicationContext applicationContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AnnotationConfigApplicationContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExtConfig.class);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 发布事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        applicationContext.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">publishEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;我发布的事件&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        applicationContext.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>运行，可以看到，现在容器中有三个事件：一个我们自定义的、一个是容器刷新时候的事件、一个是容器关闭时候的事件：</p><p><img src="`+p+'" alt="image-20220210190748526"></p><blockquote><p>步骤：</p><ol><li>写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEven及其子类）。</li><li>把监听器加入到容器中。</li><li>只要容器中有相应事件的发布，我们就能监听到这个事件。</li><li>发布一个事件：applicationContext.publishEvent();</li></ol></blockquote><h2 id="applicationlistener原理" tabindex="-1">ApplicationListener原理 <a class="header-anchor" href="#applicationlistener原理" aria-label="Permalink to &quot;ApplicationListener原理&quot;">​</a></h2><p>通过上面的例子，我们让容器收到了三个事件：ContextRefreshedEvent、ExtTest$1、ContextClosedEvent，我们来看一下ApplicationListener是如何监听这些事件的。Debug运行，可以看到在refresh方法最后有一步finishRefresh();</p><p><img src="'+e+'" alt="image-20220211131657698"></p><p>注释中也说了，在这里发布相对应的事件，也就是我们的ContextRefreshedEvent。进去就可以看到，它创建了一个ContextRefreshedEvent对象，然后将其发布出去：</p><p><img src="'+l+'" alt="image-20220211131844702"></p><p>我们进去看一下它的事件发布流程是怎样的！首先是来到我们的日志输入部分，以及判断事件是否为ApplicationEvent，如果不是就将其转为ApplicationEvent：</p><p><img src="'+h+'" alt="image-20220211144541344"></p><p>然后先获取事件的多播器（发布器）getApplicationEventMulticaster()，获取到多播器之后，再使用multicastEvent(applicationEvent, eventType)派发事件：</p><p><img src="'+k+'" alt="image-20220211144715398"></p><p>我们可以进去看它是如何派发事件的：</p><p><img src="'+r+'" alt="image-20220211144929631"></p><p>它会利用一个增强for循环获取到所有的ApplicationListener，然后判断如果有Executor，可以支持使用Executor进行异步派发；否则，直接使用同步的方式执行listener方法，拿到listener回调我们的onApplicationEvent方法。</p><p><img src="'+o+'" alt="image-20220211145322719"></p><p>如此，也就将我们的ContextRefreshedEvent事件发布出去了，其它两个事件的发布流程也都是类似的。</p><h2 id="事件多播器-派发器" tabindex="-1">事件多播器(派发器) <a class="header-anchor" href="#事件多播器-派发器" aria-label="Permalink to &quot;事件多播器(派发器)&quot;">​</a></h2><p>从上面的事件发布流程我们知道，在事件发布之前需要先获取到我们的事件多播器getApplicationEventMulticaster()，那么这个事件多播器是从哪里来的呢？我们回到我们的refresh方法里面，可以看到里面有一个initApplicationEventMulticaster()初始化应用程序的事件多播器：</p><p><img src="'+c+'" alt="image-20220211145709631"></p><p>进去可以看到，它会先去容器中找看有没有id等于applicationEventMulticaster的组件：</p><p><img src="'+g+'" alt="image-20220211145934643"></p><p>如果有，那么就会拿到这个组件；而没有，则会new SimpleApplicationEventMulticaster(beanFactory)再注册到容器中去，这样我们就可以在其它组件要派发事件时，自动注入这个applicationEventMulticaster。</p><h2 id="getapplicationlisteners-event-type" tabindex="-1">getApplicationListeners(event, type) <a class="header-anchor" href="#getapplicationlisteners-event-type" aria-label="Permalink to &quot;getApplicationListeners(event, type)&quot;">​</a></h2><p>看完事件多播器，我们再看一下容器中有哪些监听器？通过上面的事件发布流程我们知道，在派发事件时，会先获取到所有的监听器，那这些监听器是从哪里获取的？还是回到我们的refresh方法，在结束BeanFactory的初始化之前有一步registerListeners()注册监听器，我们的监听器就是在这个时候注册到容器中去的：</p><p><img src="'+E+'" alt="image-20220211150614524"></p><p>首先注册指定的静态监听器，我们这里没有。然后来到我们的String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false)从容器中拿到所有的监听器。然后再通过一个增强for将所有的监听器注册到applicationEventMulticaster中：</p><p><img src="'+d+'" alt="image-20220211150939196"></p>',35),m=[A];function D(F,v,_,u,C,x){return a(),i("div",null,m)}const B=s(y,[["render",D]]);export{b as __pageData,B as default};
