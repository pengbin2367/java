import{_ as e,c as t,o as a,a5 as r}from"./chunks/framework.BBnPlPAH.js";const u=JSON.parse('{"title":"归并分治","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/022-MergeDivideAndConquer.md","filePath":"algorithm/022-MergeDivideAndConquer.md","lastUpdated":1729870203000}'),o={name:"algorithm/022-MergeDivideAndConquer.md"},p=r('<h1 id="归并分治" tabindex="-1">归并分治 <a class="header-anchor" href="#归并分治" aria-label="Permalink to &quot;归并分治&quot;">​</a></h1><p>原理：</p><p>1）思考一个问题在大范围上的答案，是否等于，左部分的答案 + 右部分的答案 + 跨越左右产生的答案</p><p>2）计算“跨越左右产生的答案”时，如果加上左、右各自有序这个设定，会不会获得计算的便利性</p><p>3）如果以上两点都成立，那么该问题很可能被归并分治解决（话不说满，因为总有很毒的出题人）</p><p>4）求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性</p><p>补充：</p><p>1）一些用归并分治解决的问题，往往也可以用线段树、树状数组等解法。时间复杂度也都是最优解，这些数据结构都会在【必备】或者【扩展】课程阶段讲到</p><p>2）本节讲述的题目都是归并分治的常规题，难度不大。归并分治不仅可以解决简单问题，还可以解决很多较难的问题，只要符合上面说的特征。比如二维空间里任何两点间的最短距离问题，这个内容会在【挺难】课程阶段里讲述。顶级公司考这个问题的也很少，因为很难，但是这个问题本身并不冷门，来自《算法导论》原题</p><p>3）还有一个常考的算法：“整块分治”。会在【必备】课程阶段讲到</p>',10),n=[p];function i(_,d,s,c,l,h){return a(),t("div",null,n)}const f=e(o,[["render",i]]);export{u as __pageData,f as default};
