import{_ as e,c as p,o as t,a5 as a}from"./chunks/framework.BBnPlPAH.js";const g=JSON.parse('{"title":"堆结构和堆排序","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/025-HeapSort.md","filePath":"algorithm/025-HeapSort.md","lastUpdated":1729870203000}'),o={name:"algorithm/025-HeapSort.md"},n=a('<h1 id="堆结构和堆排序" tabindex="-1">堆结构和堆排序 <a class="header-anchor" href="#堆结构和堆排序" aria-label="Permalink to &quot;堆结构和堆排序&quot;">​</a></h1><p>堆结构</p><p>完全二叉树和数组前缀范围来对应：</p><ul><li><p>大小，单独的变量size来控制</p></li><li><p>i的父亲节点：(i-1)/2，i的左孩子：i<em>2 + 1，i的右孩子：i</em>2 + 2</p></li></ul><p>堆的定义（大根堆、小根堆），本节课讲解按照大根堆来讲解，小根堆是同理的。</p><p>堆的调整：heapInsert（向上调整）、heapify（向下调整）</p><p>heapInsert、heapify方法的单次调用，时间复杂度O(log n)，完全二叉树的结构决定的</p><p>堆排序</p><p>A. 从顶到底建堆，时间复杂度O(n * log n)，log1 + log2 + log3 + … + logn -&gt; O(n*logn) 或者用增倍分析法：建堆的复杂度分析+子矩阵数量的复杂度分析</p><p>B. 从底到顶建堆，时间复杂度O(n)，总代价就是简单的等比数列关系，为啥会有差异？简单图解一下</p><p>C. 建好堆之后的调整阶段，从最大值到最小值依次归位，时间复杂度O(n * log n)</p><p>时间复杂度O(n * log n)，不管以什么方式建堆，调整阶段的时间复杂度都是这个，所以整体复杂度也是这个</p><p>额外空间复杂度是O(1)，因为堆直接建立在了要排序的数组上，所以没有什么额外空间</p><p>注意：堆结构比堆排序有用的多，尤其是和比较器结合之后。后面几节课会重点讲述。</p>',14),i=[n];function r(l,_,s,c,d,h){return t(),p("div",null,i)}const f=e(o,[["render",r]]);export{g as __pageData,f as default};
