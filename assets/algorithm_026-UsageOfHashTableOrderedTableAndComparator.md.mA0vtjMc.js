import{_ as a,c as e,o as p,a5 as t}from"./chunks/framework.BAO6c_AF.js";const T=JSON.parse('{"title":"哈希表、有序表和比较器的用法","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/026-UsageOfHashTableOrderedTableAndComparator.md","filePath":"algorithm/026-UsageOfHashTableOrderedTableAndComparator.md","lastUpdated":1729870203000}'),r={name:"algorithm/026-UsageOfHashTableOrderedTableAndComparator.md"},o=t('<h1 id="哈希表、有序表和比较器的用法" tabindex="-1">哈希表、有序表和比较器的用法 <a class="header-anchor" href="#哈希表、有序表和比较器的用法" aria-label="Permalink to &quot;哈希表、有序表和比较器的用法&quot;">​</a></h1><p>哈希表的用法（认为是集合，根据值来做key 或者 根据内存地址做key）</p><p>HashSet和HashMap原理一样，有无伴随数据的区别</p><p>增、删、改、查时间为O(1)，但是大常数</p><p>所以当key的范围是固定的、可控的情况下，可以用数组结构替代哈希表结构</p><blockquote><p>注意：</p><p>Java中通过自定义hashCode、equals等方法</p><p>任何类都可以实现“根据值做key”或者“根据内存地址做key”的需求</p><p>但是这里不再展开，因为在算法学习这个范畴内，这些并不重要，还有其他语言的同学也不关心这些</p><p>笔试、面试、比赛也都不会用到，课上只说对算法学习重要的内容</p></blockquote><p>有序表的用法（认为是集合，但是有序组织）</p><p>TreeSet和TreeMap原理一样，有无伴随数据的区别</p><p>增、删、改、查 + 很多和有序相关的操作(floor、ceilling等)，时间为O(log n)</p><p>有序表比较相同的东西会去重，如果不想去重就加入更多的比较策略（比较器定制）。堆不会去重。</p><p>有序表在java里就是红黑树实现的</p><p>AVL树、SB树、替罪羊树、Treap、Splay、跳表等等很多结构都可实现同样功能</p><p>后续的课程会涉及，这里不做展开，只讲解简单用法</p><p>比较器：定制比较策略。用在排序、堆、有序表等很多需要序的结构中都可使用</p><p>定义类、直接Lamda表达式</p><p>字典序的概念</p>',16),s=[o];function l(d,_,n,c,h,i){return p(),e("div",null,s)}const f=a(r,[["render",l]]);export{T as __pageData,f as default};
