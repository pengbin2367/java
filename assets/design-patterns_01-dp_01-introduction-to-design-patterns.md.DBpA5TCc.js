import{_ as e,c as l,o as i,a5 as t}from"./chunks/framework.BAO6c_AF.js";const s="/java/assets/img.D-PtaYVi.png",P=JSON.parse('{"title":"设计模式导论","description":"","frontmatter":{},"headers":[],"relativePath":"design-patterns/01-dp/01-introduction-to-design-patterns.md","filePath":"design-patterns/01-dp/01-introduction-to-design-patterns.md","lastUpdated":1729870203000}'),a={name:"design-patterns/01-dp/01-introduction-to-design-patterns.md"},o=t('<h1 id="设计模式导论" tabindex="-1">设计模式导论 <a class="header-anchor" href="#设计模式导论" aria-label="Permalink to &quot;设计模式导论&quot;">​</a></h1><h2 id="什么是-gof" tabindex="-1">什么是 GOF <a class="header-anchor" href="#什么是-gof" aria-label="Permalink to &quot;什么是 GOF&quot;">​</a></h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书， 该书首次提到了软件开发中设计模式的概念。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>设计模式的思想总结出来就是一句话： <code>对接口编程而不是对实现编程，优先使用对象组合而不是继承</code></p></div><h2 id="设计模式总览" tabindex="-1">设计模式总览 <a class="header-anchor" href="#设计模式总览" aria-label="Permalink to &quot;设计模式总览&quot;">​</a></h2><details class="details custom-block"><summary>5+7+10</summary><ul><li>创建型模式（Creational Patterns） <ul><li>单例（Singleton）模式</li><li>原型（Prototype）模式</li><li>工厂方法（FactoryMethod）模式</li><li>抽象工厂（AbstractFactory）模式</li><li>建造者（Builder）模式</li></ul></li><li>结构型模式（Structural Patterns） <ul><li>代理（Proxy）模式</li><li>适配器（Adapter）模式</li><li>桥接（Bridge）模式</li><li>装饰（Decorator）模式</li><li>外观（Facade）模式</li><li>享元（Flyweight）模式</li><li>组合（Composite）模式</li><li>过滤器模式（Filter Pattern）</li></ul></li><li>行为型模式（Behavioral Patterns） <ul><li>模板方法（Template Method）模式</li><li>策略（Strategy）模式</li><li>命令（Command）模式</li><li>职责链（Chain of Responsibility）模式</li><li>状态（State）模式</li><li>观察者（Observer）模式</li><li>中介者（Mediator）模式</li><li>迭代器（Iterator）模式</li><li>访问者（Visitor）模式</li><li>备忘录（Memento）模式</li><li>解释器（Interpreter）模式</li></ul></li></ul></details><p>我们可以通过一张组件的生命周期图来理解一下这三种分类：</p><p><img src="'+s+'" alt="img"></p><h2 id="设计的-7-大原则" tabindex="-1">设计的 7 大原则 <a class="header-anchor" href="#设计的-7-大原则" aria-label="Permalink to &quot;设计的 7 大原则&quot;">​</a></h2><details class="details custom-block"><summary>开闭原则-扩展新类而不是修改旧类</summary><p>Open Closed Principle，OCP</p><ul><li>软件实体应当对 <code>扩展开放</code>，对 <code>修改关闭</code>（Software entities should be open for extension，but closed for modification）</li><li>合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范</li></ul></details><details class="details custom-block"><summary>里氏替换原则-继承父类而不去改变父类</summary><p>Liskov Substitution Principle，LSP</p><ul><li>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</li></ul></details><details class="details custom-block"><summary>依赖倒置原则-面向接口编程，而不是面向实现类</summary><p>Dependence Inversion Principle，DIP</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</li></ul></details><details class="details custom-block"><summary>单一职责原则-每个类只负责自己的事情，而不是变成万能</summary><p>Single Responsibility Principle，SRP</p><ul><li>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）</li></ul></details><details class="details custom-block"><summary>接口隔离原则-各个类建立自己的专用接口，而不是建立万能接口</summary><p>Interface Segregation Principle，ISP</p><ul><li>一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）</li></ul></details><details class="details custom-block"><summary>迪米特法则-无需直接交互的两个类，如果需要交互，使用中间者</summary><p>Law of Demeter，LoD</p><ul><li>最少知识原则（Least Knowledge Principle，LKP)</li><li>只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）</li></ul><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低</p></div></details><details class="details custom-block"><summary>合成复用原则-优先组合，其次继承</summary><p>Composite Reuse Principle，CRP</p><ul><li>又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）</li><li>软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</li></ul></details>',16),r=[o];function n(d,c,u,p,m,h){return i(),l("div",null,r)}const y=e(a,[["render",n]]);export{P as __pageData,y as default};
